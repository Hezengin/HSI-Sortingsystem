import cv2 as cv
import numpy as np
import matplotlib.pyplot as plt

def generate_rgb_composite(data_cube, bands, red_range=(620, 750), green_range=(495, 570), blue_range=(450, 495)):
    red_band = np.argmin(np.abs(bands - np.mean(red_range)))
    green_band = np.argmin(np.abs(bands - np.mean(green_range)))
    blue_band = np.argmin(np.abs(bands - np.mean(blue_range)))

    rgb = np.stack([data_cube[:, red_band, :], data_cube[:, green_band, :], data_cube[:, blue_band, :]], axis=-1)

    rgb_norm = rgb - rgb.min(axis=(0, 1), keepdims=True)
    rgb_norm = rgb_norm / rgb_norm.max(axis=(0, 1), keepdims=True)

    gamma = 1.5
    rgb_composite = np.power(rgb_norm, 1 / gamma)
    return rgb_composite

data_cube = np.load('Datacubes/09_05_2025/data_cube_20250509_151914.npy', allow_pickle=True)
bands = np.genfromtxt('bands/bands.csv', delimiter=',')  # Load the bands
rgb_composite = generate_rgb_composite(data_cube, bands)

rgb_uint8 = (rgb_composite * 255).astype(np.uint8)

# Stap 3: BGR naar HSV
hsv_img = cv.cvtColor(rgb_uint8, cv.COLOR_RGB2HSV)

# Use your fixed HSV range
lower_bound = np.array([0, 20, 0])
upper_bound = np.array([120, 255, 157])

# Get binary mask
mask = cv.inRange(hsv_img, lower_bound, upper_bound)

# Find contours in the mask (instead of grayscale threshold)
contours, hierarchy = cv.findContours(mask, cv.RETR_TREE, cv.CHAIN_APPROX_SIMPLE)

# Draw and show result except the largest one cnt = contours[0]
print(len(contours))
for i in range(1, len(contours)):    
    cv.drawContours(hsv_img, [contours[i]], 0, (1,0,0), 2)
    
    
import os

# Directory to save crops
output_dir = 'Datacubes/Crops'
os.makedirs(output_dir, exist_ok=True)

for i in range(1, len(contours)):
    cnt = contours[i]
    x, y, w, h = cv.boundingRect(cnt)  # Get bounding box
    
     # Filter: ruis
    if w < 15 or h < 15:
        print(f"[SKIP] Contour {i} too small: w={w}, h={h}")
        continue
    
    # Crop the data cube using bounding box
    # Shape of data_cube: (height, spectral_bands, width)
    cropped_cube = data_cube[y:y+h, :, x:x+w]

    # Save cropped cube
    crop_filename = os.path.join(output_dir, f'crop_{i}.npy')
    np.save(crop_filename, cropped_cube)
    print(f"Saved: {crop_filename} with shape {cropped_cube.shape}")
